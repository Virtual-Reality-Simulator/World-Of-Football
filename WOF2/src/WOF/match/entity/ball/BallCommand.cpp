#include "Ball.h"
#include "../../Match.h"

#include "BallCommand.h"

#include "../footballer/Footballer.h"

DECLARE_INSTANCE_TYPE_NAME(WOF::match::BallCommand, CBallCommand);

namespace WOF { namespace match {

const TCHAR* BallCommand::ScriptClassName = L"CBallCommand";

void BallCommand::declareInVM(SquirrelVM& target) {

	SqPlus::SQClassDef<BallCommand>(BallCommand::ScriptClassName).
		enumInt(BallCommand_None, L"Type_None").
		enumInt(BallCommand_Pos, L"Type_Pos").
		enumInt(BallCommand_Vel, L"Type_Vel").
		enumInt(BallCommand_AfterTouch, L"Type_AfterTouch").
		enumInt(BallCommand_Guard, L"Type_Guard").
		func(&BallCommand::script_isValid, L"isValid").
		func(&BallCommand::invalidate, L"invalidate").
		func(&BallCommand::invalidateAndNotify, L"invalidateAndNotify").
		func(&BallCommand::script_setType, L"setType").
		func(&BallCommand::script_getType, L"getType").
		func(&BallCommand::script_getControlStrength, L"getControlStrength").
		func(&BallCommand::script_getID, L"getID").
		func(&BallCommand::script_getSource, L"getSource").
		func(&BallCommand::script_mergeWith, L"mergeWith").
		func(&BallCommand::script__setVel, L"_setVel");
}

void BallCommand::script__setVel(Ball* pBall, unsigned int commandID, float controlStrength, CtVector3* v, CtVector3* w, float switchControlInfluence, bool enableAfterTouch) {

	Object object;
	object.objectType = Node_None;

	setVel(dref(pBall), commandID, object, controlStrength, Vector3(dref(v)), Vector3(dref(w)), switchControlInfluence, enableAfterTouch);
}

TeamEnum BallCommand::extractTeam(TeamEnum defaultTeam) const {

	if (source.isValid() && source->objectType == Node_Footballer) {

		return (Footballer::footballerFromObject(source.ptr()))->mTeam;
	}

	return defaultTeam;
}

void BallCommand::setGuard(Ball& _ball, unsigned int commandID, Object& _source, const float& _controlStrength) {

	ID = commandID;
	ball = &_ball;

	controlStrength = _controlStrength;

	source = &_source;
	type = BallCommand_Guard;
}

void BallCommand::setPos(Ball& _ball, unsigned int commandID, Object& _source, const float& _controlStrength, const Vector3& _pos, const bool& _rotate, const CtVector3* pRotateNormal) {

	ID = commandID;
	ball = &_ball;

	controlStrength = _controlStrength;

	source = &_source;
	type = BallCommand_Pos;
	
	pos.pos = _pos;

	const Clock& clock = ball->mNodeMatch->getClock();
	float dt = clock.getFramePhysTickCount() * clock.getFramePhysTickLength();

	//sync phys props
	Vector3 posDiff;
	pos.pos.subtract(ball->getPos(), posDiff);
	posDiff.div(dt, pos.v);

	if (_rotate) {

		ball->calcVelocitySyncedW(pos.v, dref(pRotateNormal), pos.w);

	} else {

		pos.w.zero();
	}

	//smooth synced physics properties, we really want the teleport to only 
	//look correct (rotations) but not have super speeds and rotations generated by 
	//the 'teleport' which although physically correct are not useful
	{
		//we cannot manipulate v becuase it is used to produce the actual
		//pos movement in the physics processing
		//pos.v.zero();
		
		float posDiffMag = posDiff.mag();
		float scale = posDiffMag / _ball.getRadius();

		//if ball was teleported by more than its radius, we scale down the auto generated w 
		if (scale > 1.1f) {

			pos.w.div(scale);
		}
	}
}

void BallCommand::setVel(Ball& _ball, unsigned int commandID, Object& _source, const float& _controlStrength, const Vector3& _v, const Vector3& _w, float _switchControlInfluence, bool _enableAfterTouch) {

	ID = commandID;
	ball = &_ball;

	controlStrength = _controlStrength;

	source = &_source;
	type = BallCommand_Vel;

	vel.v = _v;
	vel.w = _w;

	vel.switchControlInfluence = _switchControlInfluence;
	vel.enableAfterTouch = _enableAfterTouch;
}

void BallCommand::setAfterTouch(Ball& _ball, unsigned int commandID, Object& _source, const float& _controlStrength, const Vector3& _acc, const float& _rotSyncRatio) {

	ID = commandID;
	ball = &_ball;

	controlStrength = _controlStrength;

	source = &_source;
	type = BallCommand_AfterTouch;

	afterTouch.acceleration = _acc;
	afterTouch.rotSyncRatio = _rotSyncRatio;
}

void merge_VW(Ball& ball, const BallCommandVW& cmd1, const BallCommandVW& cmd2, float cmd1Ratio, float randomRatio, BallCommandVW& result) {

	float randMin = -randomRatio * 1.0f;
	float randMax = randomRatio * 1.0f;

	lerp(cmd1.v, cmd2.v, cmd1Ratio + trand2(randMin, randMax), result.v);
	lerp(cmd1.w, cmd2.w, cmd1Ratio + trand2(randMin, randMax), result.w);
}

void merge_Pos_Pos(Ball& ball, BallCommand& cmd1, BallCommand& cmd2, float cmd1MergeRatio, float randomRatio, BallCommand& result) {

	result.type = BallCommand_Vel;
	result.vel.enableAfterTouch = false;
	result.vel.switchControlInfluence = 0.0f;

	merge_VW(ball, cmd1.pos, cmd2.pos, cmd1MergeRatio, randomRatio, result.vel);
}

void merge_Pos_Vel(Ball& ball, const BallCommand& cmdPos, const BallCommand& cmdVel, float velCmdRatio, float randomRatio, BallCommand& result) {

	result.type = BallCommand_Vel;
	result.vel.enableAfterTouch = false;
	result.vel.switchControlInfluence = 0.0f;

	merge_VW(ball, cmdVel.vel, cmdPos.pos, velCmdRatio, randomRatio, result.vel);
}

void merge_Vel_Vel(Ball& ball, const BallCommand& cmd1, const BallCommand& cmd2, float cmd1MergeRatio, float randomRatio, BallCommand& result) {

	result.type = BallCommand_Vel;
	result.vel.enableAfterTouch = false;
	result.vel.switchControlInfluence = 0.0f;

	merge_VW(ball, cmd1.vel, cmd2.vel, cmd1MergeRatio, randomRatio, result.vel);
}

void BallCommand::mergeWith_None_None(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {
}

void BallCommand::mergeWith_None_Pos(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	*this = command;
}

void BallCommand::mergeWith_None_Vel(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	*this = command;
}

void BallCommand::mergeWith_None_AfterTouch(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	*this = command;
}

void BallCommand::mergeWith_None_Guard(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	*this = command;
}

void BallCommand::mergeWith_Pos_None(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {
}

void BallCommand::mergeWith_Pos_Pos(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Pos(ball, temp, command, selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Pos_Vel(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Vel(ball, temp, command, 1.0f - selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Pos_AfterTouch(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	command.invalidate();
}

void BallCommand::fillGuardAsPos(Ball& ball) {

	pos.pos = ball.getPos();
	pos.v = dref(ball.getVel()); 
	pos.w = dref(ball.getW()); 
}

void BallCommand::mergeWith_Pos_Guard(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	command.fillGuardAsPos(ball);

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Pos(ball, temp, command, selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Vel_None(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {
}

void BallCommand::mergeWith_Vel_Pos(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Vel(ball, command, temp, selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Vel_Vel(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Vel_Vel(ball, temp, command, selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Vel_AfterTouch(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	command.invalidateAndNotify();
}

void BallCommand::mergeWith_Vel_Guard(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	command.fillGuardAsPos(ball);

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Vel(ball, command, temp, selfMergeRatio, randomRatio, *this);
}


void BallCommand::mergeWith_AfterTouch_None(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {
}

void BallCommand::mergeWith_AfterTouch_Pos(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	
	*this = command;
}

void BallCommand::mergeWith_AfterTouch_Vel(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	
	*this = command;
}

void BallCommand::mergeWith_AfterTouch_AfterTouch(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	command.invalidateAndNotify();
}

void BallCommand::mergeWith_AfterTouch_Guard(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();

	*this = command;
}


void BallCommand::mergeWith_Guard_None(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {
}

void BallCommand::mergeWith_Guard_Pos(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	fillGuardAsPos(ball);

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Pos(ball, temp, command, selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Guard_Vel(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	fillGuardAsPos(ball);

	invalidateAndNotify();
	command.invalidateAndNotify();

	BallCommand temp = *this;

	merge_Pos_Vel(ball, temp, command, 1.0f - selfMergeRatio, randomRatio, *this);
}

void BallCommand::mergeWith_Guard_AfterTouch(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	command.invalidateAndNotify();
}

void BallCommand::mergeWith_Guard_Guard(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {

	invalidateAndNotify();
	command.invalidateAndNotify();
}

void BallCommand::mergeWith(Ball& ball, BallCommand& command, float selfMergeRatio, float randomRatio) {


	switch (type) {

		case BallCommand_None: {

			switch (command.type) {

				case BallCommand_None: {

					mergeWith_None_None(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Pos: {

					mergeWith_None_Pos(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Vel: {

					mergeWith_None_Vel(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_AfterTouch: {

					mergeWith_None_AfterTouch(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Guard: {

					mergeWith_None_Guard(ball, command, selfMergeRatio, randomRatio);

				} break;
			}

		} break;


		case BallCommand_Pos: {

			switch (command.type) {

				case BallCommand_None: {

					mergeWith_Pos_None(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Pos: {

					mergeWith_Pos_Pos(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Vel: {

					mergeWith_Pos_Vel(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_AfterTouch: {

					mergeWith_Pos_AfterTouch(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Guard: {

					mergeWith_Pos_Guard(ball, command, selfMergeRatio, randomRatio);

				} break;
			}

		} break;


		case BallCommand_Vel: {

			switch (command.type) {

				case BallCommand_None: {

					mergeWith_Vel_None(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Pos: {

					mergeWith_Vel_Pos(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Vel: {

					mergeWith_Vel_Vel(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_AfterTouch: {

					mergeWith_Vel_AfterTouch(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Guard: {

					mergeWith_Vel_Guard(ball, command, selfMergeRatio, randomRatio);

				} break;
			}

		} break;


		case BallCommand_AfterTouch: {

			switch (command.type) {

				case BallCommand_None: {

					mergeWith_AfterTouch_None(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Pos: {

					mergeWith_AfterTouch_Pos(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Vel: {

					mergeWith_AfterTouch_Vel(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_AfterTouch: {

					mergeWith_AfterTouch_AfterTouch(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Guard: {

					mergeWith_AfterTouch_Guard(ball, command, selfMergeRatio, randomRatio);

				} break;
			}

		} break;

		case BallCommand_Guard: {

			switch (command.type) {

				case BallCommand_None: {

					mergeWith_Guard_None(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Pos: {

					mergeWith_Guard_Pos(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Vel: {

					mergeWith_Guard_Vel(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_AfterTouch: {

					mergeWith_Guard_AfterTouch(ball, command, selfMergeRatio, randomRatio);

				} break;

				case BallCommand_Guard: {

					mergeWith_Guard_Guard(ball, command, selfMergeRatio, randomRatio);

				} break;
			}

		} break;
	}
}

void BallCommand::invalidateAndNotify() {

	notifyRejected();

	invalidate();
}

void BallCommand::notifyRejected() {

	if (source.isValid() && (source->objectType == Node_Footballer)) {

		Footballer::footballerFromObject(source)->onBallCommandRejected(ball, ID);
	}
}


} }